# Autogenerated using ProtoBuf.jl v1.2.0 on 2026-01-15T19:14:23.101
# original file: /home/scelles-admin/.julia/dev/gRPCServer/examples/calculator/calculator.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export CalculatorResponse, CalculatorRequest


struct CalculatorResponse
    result::Float64
end
CalculatorResponse(; result::Float64 = zero(Float64)) = CalculatorResponse(result)
PB.default_values(::Type{CalculatorResponse}) = (;result = zero(Float64))
PB.field_numbers(::Type{CalculatorResponse}) = (;result = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CalculatorResponse})
    result = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            result = PB.decode(d, Float64)
        else
            Base.skip(d, wire_type)
        end
    end
    return CalculatorResponse(result)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CalculatorResponse)
    initpos = position(e.io)
    x.result !== zero(Float64) && PB.encode(e, 1, x.result)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CalculatorResponse)
    encoded_size = 0
    x.result !== zero(Float64) && (encoded_size += PB._encoded_size(x.result, 1))
    return encoded_size
end

struct CalculatorRequest
    first_number::Float64
    second_number::Float64
end
CalculatorRequest(; first_number::Float64 = zero(Float64), second_number::Float64 = zero(Float64)) = CalculatorRequest(first_number, second_number)
PB.default_values(::Type{CalculatorRequest}) = (;first_number = zero(Float64), second_number = zero(Float64))
PB.field_numbers(::Type{CalculatorRequest}) = (;first_number = 1, second_number = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CalculatorRequest})
    first_number = zero(Float64)
    second_number = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            first_number = PB.decode(d, Float64)
        elseif field_number == 2
            second_number = PB.decode(d, Float64)
        else
            Base.skip(d, wire_type)
        end
    end
    return CalculatorRequest(first_number, second_number)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CalculatorRequest)
    initpos = position(e.io)
    x.first_number !== zero(Float64) && PB.encode(e, 1, x.first_number)
    x.second_number !== zero(Float64) && PB.encode(e, 2, x.second_number)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CalculatorRequest)
    encoded_size = 0
    x.first_number !== zero(Float64) && (encoded_size += PB._encoded_size(x.first_number, 1))
    x.second_number !== zero(Float64) && (encoded_size += PB._encoded_size(x.second_number, 2))
    return encoded_size
end

# TODO: SERVICE
#    Calculator
