var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Module","page":"API Reference","title":"Module","text":"","category":"section"},{"location":"api/#Server-Types","page":"API Reference","title":"Server Types","text":"","category":"section"},{"location":"api/#Context-Types","page":"API Reference","title":"Context Types","text":"","category":"section"},{"location":"api/#Service-Registration","page":"API Reference","title":"Service Registration","text":"","category":"section"},{"location":"api/#Stream-Types","page":"API Reference","title":"Stream Types","text":"","category":"section"},{"location":"api/#Error-Handling","page":"API Reference","title":"Error Handling","text":"","category":"section"},{"location":"api/#Interceptors","page":"API Reference","title":"Interceptors","text":"","category":"section"},{"location":"api/#Health-Checking","page":"API Reference","title":"Health Checking","text":"","category":"section"},{"location":"api/#Reflection-Support","page":"API Reference","title":"Reflection Support","text":"","category":"section"},{"location":"api/#Server-Lifecycle","page":"API Reference","title":"Server Lifecycle","text":"","category":"section"},{"location":"api/#TLS","page":"API Reference","title":"TLS","text":"","category":"section"},{"location":"api/#Context-Operations","page":"API Reference","title":"Context Operations","text":"","category":"section"},{"location":"api/#Compression","page":"API Reference","title":"Compression","text":"","category":"section"},{"location":"api/#HTTP/2-Stream-State","page":"API Reference","title":"HTTP/2 Stream State","text":"These functions are used for advanced stream state management, particularly for handling edge cases with client disconnection.","category":"section"},{"location":"api/#Internal-Types","page":"API Reference","title":"Internal Types","text":"These are internal types used by the HTTP/2 implementation. They are documented for reference but are not part of the public API.","category":"section"},{"location":"api/#gRPCServer","page":"API Reference","title":"gRPCServer","text":"gRPCServer\n\nA native Julia implementation of a gRPC server library.\n\ngRPCServer enables Julia developers to expose services over the gRPC protocol with support for all four RPC patterns (unary, server streaming, client streaming, bidirectional), interceptors, health checking, reflection, TLS/mTLS, and compression.\n\nQuick Start\n\nusing gRPCServer\n\n# Create server\nserver = GRPCServer(\"127.0.0.1\", 50051)\n\n# Register your service\nregister!(server, MyService())\n\n# Start server\nrun(server)\n\nSee the documentation for more examples and API reference.\n\n\n\n\n\n","category":"module"},{"location":"api/#gRPCServer.GRPCServer","page":"API Reference","title":"gRPCServer.GRPCServer","text":"GRPCServer\n\nThe main gRPC server managing connections, services, and lifecycle.\n\nFields\n\nhost::String: Server bind address\nport::Int: Server port\nconfig::ServerConfig: Server configuration\nstatus::ServerStatus.T: Current lifecycle state\ndispatcher::RequestDispatcher: Request dispatcher\nhealth_status::Dict{String, HealthStatus.T}: Per-service health status\n\nExample\n\nserver = GRPCServer(\"0.0.0.0\", 50051)\nregister!(server, GreeterService())\nrun(server)\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.ServerConfig","page":"API Reference","title":"gRPCServer.ServerConfig","text":"ServerConfig\n\nConfiguration container for gRPC server options.\n\nFields\n\nConnection Limits\n\nmax_connections::Union{Int, Nothing}: Maximum concurrent connections (nothing = unlimited)\nmax_concurrent_streams::Int: Maximum streams per connection (default: 100)\nmax_concurrent_requests::Union{Int, Nothing}: Maximum concurrent requests (nothing = unlimited)\nmax_queued_requests::Int: Maximum queued requests when at capacity (default: 1000)\n\nMessage Limits\n\nmax_message_size::Int: Maximum message size in bytes (default: 4MB)\n\nTimeouts (in seconds)\n\nkeepalive_interval::Union{Float64, Nothing}: Interval for keepalive pings (nothing = disabled)\nkeepalive_timeout::Float64: Timeout for keepalive response (default: 20.0)\nidle_timeout::Union{Float64, Nothing}: Close idle connections after this time (nothing = never)\ndrain_timeout::Float64: Maximum time to wait for graceful shutdown (default: 30.0)\n\nTLS\n\ntls::Union{TLSConfig, Nothing}: TLS configuration (nothing = insecure)\n\nFeature Toggles\n\nenable_health_check::Bool: Enable built-in health checking service (default: false)\nenable_reflection::Bool: Enable gRPC reflection service (default: false)\ndebug_mode::Bool: Include exception details in error responses (default: false)\nlog_requests::Bool: Log all incoming requests (default: false)\n\nCompression\n\ncompression_enabled::Bool: Enable message compression (default: true)\ncompression_threshold::Int: Minimum bytes before compression (default: 1024)\nsupported_codecs::Vector{CompressionCodec.T}: Supported compression codecs\n\nExample\n\nconfig = ServerConfig(\n    max_message_size = 8 * 1024 * 1024,  # 8MB\n    enable_health_check = true,\n    enable_reflection = true,\n    debug_mode = false\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.TLSConfig","page":"API Reference","title":"gRPCServer.TLSConfig","text":"TLSConfig\n\nTLS/mTLS configuration for secure connections.\n\nFields\n\ncert_chain::String: Path to server certificate chain (PEM)\nprivate_key::String: Path to server private key (PEM)\nclient_ca::Union{String, Nothing}: Path to client CA certificate for mTLS\nrequire_client_cert::Bool: Whether to require client certificates\nmin_version::Symbol: Minimum TLS version (:TLSv1_2 or :TLSv1_3)\n\nExample\n\ntls = TLSConfig(\n    cert_chain = \"/path/to/server.crt\",\n    private_key = \"/path/to/server.key\",\n    client_ca = \"/path/to/ca.crt\",  # For mTLS\n    require_client_cert = true,\n    min_version = :TLSv1_2\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.ServerStatus","page":"API Reference","title":"gRPCServer.ServerStatus","text":"ServerStatus\n\nRepresents the lifecycle state of a gRPC server.\n\nStates\n\nSTOPPED: Server is not running\nSTARTING: Server is binding to address\nRUNNING: Server is accepting connections\nDRAINING: Server is completing in-flight requests\nSTOPPING: Server is releasing resources\n\n\n\n\n\n","category":"module"},{"location":"api/#gRPCServer.ServerContext","page":"API Reference","title":"gRPCServer.ServerContext","text":"ServerContext\n\nRequest-scoped context provided to handler functions.\n\nFields\n\nrequest_id::UUID: Unique identifier for this request\nmethod::String: Full method path (e.g., \"/helloworld.Greeter/SayHello\")\nauthority::String: Authority from :authority pseudo-header\nmetadata::Dict{String, Union{String, Vector{UInt8}}}: Request metadata\nresponse_headers::Dict{String, Union{String, Vector{UInt8}}}: Response headers to send\ntrailers::Dict{String, Union{String, Vector{UInt8}}}: Trailing metadata to send\ndeadline::Union{DateTime, Nothing}: Request deadline (nothing = no deadline)\ncancelled::Bool: Whether the request has been cancelled\npeer::PeerInfo: Client connection information\ntrace_context::Union{Vector{UInt8}, Nothing}: Distributed tracing context\n\nExample\n\nfunction say_hello(ctx::ServerContext, request::HelloRequest)::HelloReply\n    @info \"Request\" id=ctx.request_id method=ctx.method\n\n    # Check cancellation\n    if is_cancelled(ctx)\n        throw(GRPCError(StatusCode.CANCELLED, \"Request cancelled\"))\n    end\n\n    # Set response header\n    set_header!(ctx, \"x-request-id\", string(ctx.request_id))\n\n    # Check deadline\n    remaining = remaining_time(ctx)\n    if remaining !== nothing && remaining < 0\n        throw(GRPCError(StatusCode.DEADLINE_EXCEEDED, \"Deadline exceeded\"))\n    end\n\n    HelloReply(message = \"Hello, $(request.name)!\")\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.PeerInfo","page":"API Reference","title":"gRPCServer.PeerInfo","text":"PeerInfo\n\nClient connection information.\n\nFields\n\naddress::Union{IPv4, IPv6}: Client IP address\nport::Int: Client port\ncertificate::Union{Vector{UInt8}, Nothing}: Client certificate for mTLS (DER-encoded)\n\nExample\n\npeer = ctx.peer\n@info \"Client connected from $(peer.address):$(peer.port)\"\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.ServiceDescriptor","page":"API Reference","title":"gRPCServer.ServiceDescriptor","text":"ServiceDescriptor\n\nDescribes a gRPC service and its methods.\n\nFields\n\nname::String: Fully-qualified service name (e.g., \"helloworld.Greeter\")\nmethods::Dict{String, MethodDescriptor}: Methods keyed by name\nfile_descriptor::Union{Vector{UInt8}, Nothing}: File descriptor for reflection (optional)\n\nExample\n\nservice = ServiceDescriptor(\n    \"helloworld.Greeter\",\n    Dict(\n        \"SayHello\" => MethodDescriptor(\n            \"SayHello\",\n            MethodType.UNARY,\n            \"helloworld.HelloRequest\",\n            \"helloworld.HelloReply\",\n            say_hello\n        )\n    ),\n    nothing\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.MethodDescriptor","page":"API Reference","title":"gRPCServer.MethodDescriptor","text":"MethodDescriptor\n\nDescribes a single RPC method.\n\nFields\n\nname::String: Method name (e.g., \"SayHello\")\nmethod_type::MethodType.T: RPC pattern type\ninput_type::String: Fully-qualified request message type name\noutput_type::String: Fully-qualified response message type name\nhandler::Function: Handler function reference\n\nHandler Signatures by MethodType\n\nUNARY: (ctx::ServerContext, request::T) -> R\nSERVER_STREAMING: (ctx::ServerContext, request::T, stream::ServerStream{R}) -> Nothing\nCLIENT_STREAMING: (ctx::ServerContext, stream::ClientStream{T}) -> R\nBIDI_STREAMING: (ctx::ServerContext, stream::BidiStream{T,R}) -> Nothing\n\nExample\n\nmethod = MethodDescriptor(\n    \"SayHello\",\n    MethodType.UNARY,\n    \"helloworld.HelloRequest\",\n    \"helloworld.HelloReply\",\n    say_hello\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.MethodType","page":"API Reference","title":"gRPCServer.MethodType","text":"MethodType\n\nClassifies RPC method patterns.\n\nValues\n\nUNARY: Single request, single response\nSERVER_STREAMING: Single request, multiple responses\nCLIENT_STREAMING: Multiple requests, single response\nBIDI_STREAMING: Multiple requests, multiple responses\n\n\n\n\n\n","category":"module"},{"location":"api/#gRPCServer.register!","page":"API Reference","title":"gRPCServer.register!","text":"register!(registry::ServiceRegistry, descriptor::ServiceDescriptor)\n\nRegister a service in the registry. Also auto-registers protobuf types if Julia types were provided in MethodDescriptor.\n\n\n\n\n\nregister!(server::GRPCServer, service)\n\nRegister a service with the server.\n\nThe service must implement service_descriptor(service) to provide its ServiceDescriptor.\n\nArguments\n\nserver::GRPCServer: The server to register with\nservice: A service implementation\n\nThrows\n\nInvalidServerStateError: If server is not in STOPPED state\nServiceAlreadyRegisteredError: If service is already registered\n\nExample\n\nserver = GRPCServer(\"0.0.0.0\", 50051)\nregister!(server, GreeterService())\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.services","page":"API Reference","title":"gRPCServer.services","text":"services(server::GRPCServer) -> Vector{String}\n\nGet a list of registered service names.\n\nExample\n\nfor service_name in services(server)\n    println(service_name)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.service_descriptor","page":"API Reference","title":"gRPCServer.service_descriptor","text":"service_descriptor(service) -> ServiceDescriptor\n\nGet the service descriptor for a service implementation.\n\nThis function should be overloaded for custom service types.\n\nExample\n\nstruct GreeterService end\n\nfunction gRPCServer.service_descriptor(::GreeterService)\n    ServiceDescriptor(\n        \"helloworld.Greeter\",\n        Dict(\n            \"SayHello\" => MethodDescriptor(\n                \"SayHello\", MethodType.UNARY,\n                \"helloworld.HelloRequest\", \"helloworld.HelloReply\",\n                say_hello\n            )\n        ),\n        nothing\n    )\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.ServerStream","page":"API Reference","title":"gRPCServer.ServerStream","text":"ServerStream{T}\n\nOutgoing stream for server streaming and bidirectional RPCs.\n\nType parameter T is the response message type.\n\nMethods\n\nsend!(stream, message): Send a message\nclose!(stream): End the stream\n\nExample\n\nfunction list_features(ctx::ServerContext, request::Rectangle, stream::ServerStream{Feature})\n    for feature in find_features(request)\n        send!(stream, feature)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.ClientStream","page":"API Reference","title":"gRPCServer.ClientStream","text":"ClientStream{T}\n\nIncoming stream for client streaming and bidirectional RPCs.\n\nType parameter T is the request message type.\n\nImplements the Julia iterator interface for use in for loops.\n\nExample\n\nfunction record_route(ctx::ServerContext, stream::ClientStream{Point})::RouteSummary\n    point_count = 0\n    for point in stream\n        point_count += 1\n        # Process each point\n    end\n    return RouteSummary(point_count=point_count)\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.BidiStream","page":"API Reference","title":"gRPCServer.BidiStream","text":"BidiStream{T, R}\n\nBidirectional stream combining input (T) and output (R) streams.\n\nType parameters:\n\nT: Request message type (incoming)\nR: Response message type (outgoing)\n\nImplements the iterator interface for incoming messages and provides send! for outgoing messages.\n\nExample\n\nfunction route_chat(ctx::ServerContext, stream::BidiStream{RouteNote, RouteNote})\n    for note in stream  # Iterate incoming messages\n        # Echo back each note\n        send!(stream, note)\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.send!","page":"API Reference","title":"gRPCServer.send!","text":"send!(stream::ServerStream{T}, message::T) where T\nsend!(stream::ServerStream{T}, message::T; compress::Bool=true) where T\n\nSend a message on the server stream.\n\nArguments\n\nstream::ServerStream{T}: The stream to send on\nmessage::T: The message to send\ncompress::Bool=true: Whether to compress the message (if compression is negotiated)\n\nThrows\n\nStreamCancelledError: If the stream has been cancelled\nArgumentError: If the stream is closed\n\nExample\n\nsend!(stream, Feature(name=\"Feature 1\", location=Point(latitude=1, longitude=2)))\n\n\n\n\n\nsend!(stream::BidiStream{T, R}, message::R) where {T, R}\nsend!(stream::BidiStream{T, R}, message::R; compress::Bool=true) where {T, R}\n\nSend a message on the bidirectional stream.\n\nExample\n\nsend!(stream, RouteNote(message=\"Hello\", location=point))\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.close!","page":"API Reference","title":"gRPCServer.close!","text":"close!(stream::BidiStream)\n\nClose the output side of the bidirectional stream.\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.StatusCode","page":"API Reference","title":"gRPCServer.StatusCode","text":"StatusCode\n\nStandard gRPC status codes per specification.\n\nStatus Codes\n\nOK (0): Not an error; returned on success\nCANCELLED (1): Operation was cancelled\nUNKNOWN (2): Unknown error\nINVALID_ARGUMENT (3): Invalid argument provided\nDEADLINE_EXCEEDED (4): Deadline expired before completion\nNOT_FOUND (5): Requested entity not found\nALREADY_EXISTS (6): Entity already exists\nPERMISSION_DENIED (7): Permission denied\nRESOURCE_EXHAUSTED (8): Resource exhausted\nFAILED_PRECONDITION (9): Precondition check failed\nABORTED (10): Operation aborted\nOUT_OF_RANGE (11): Value out of range\nUNIMPLEMENTED (12): Operation not implemented\nINTERNAL (13): Internal error\nUNAVAILABLE (14): Service unavailable\nDATA_LOSS (15): Data loss or corruption\nUNAUTHENTICATED (16): Request not authenticated\n\n\n\n\n\n","category":"module"},{"location":"api/#gRPCServer.GRPCError","page":"API Reference","title":"gRPCServer.GRPCError","text":"GRPCError <: Exception\n\nException type for gRPC errors with status code, message, and optional details.\n\nFields\n\ncode::StatusCode.T: The gRPC status code\nmessage::String: Human-readable error message\ndetails::Vector{Any}: Additional error details (rich error model)\n\nExample\n\nthrow(GRPCError(StatusCode.NOT_FOUND, \"User not found\", []))\nthrow(GRPCError(StatusCode.INVALID_ARGUMENT, \"Name cannot be empty\"))\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.BindError","page":"API Reference","title":"gRPCServer.BindError","text":"BindError <: Exception\n\nException thrown when the server fails to bind to the configured address.\n\nFields\n\nmessage::String: Description of the bind failure\ncause::Union{Exception, Nothing}: Underlying exception if available\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.ServiceAlreadyRegisteredError","page":"API Reference","title":"gRPCServer.ServiceAlreadyRegisteredError","text":"ServiceAlreadyRegisteredError <: Exception\n\nException thrown when attempting to register a service with a name that already exists.\n\nFields\n\nservice_name::String: The duplicate service name\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.InvalidServerStateError","page":"API Reference","title":"gRPCServer.InvalidServerStateError","text":"InvalidServerStateError <: Exception\n\nException thrown when an operation is attempted in an invalid server state.\n\nFields\n\nexpected::ServerStatus.T: The expected server state\nactual::ServerStatus.T: The actual server state\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.MethodSignatureError","page":"API Reference","title":"gRPCServer.MethodSignatureError","text":"MethodSignatureError <: Exception\n\nException thrown when a handler method has an invalid signature.\n\nFields\n\nmethod_name::String: The method with invalid signature\nexpected::String: Description of expected signature\nactual::String: Description of actual signature\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.StreamCancelledError","page":"API Reference","title":"gRPCServer.StreamCancelledError","text":"StreamCancelledError <: Exception\n\nException thrown when a stream operation is attempted on a cancelled stream.\n\nFields\n\nreason::String: The reason for cancellation\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.Interceptor","page":"API Reference","title":"gRPCServer.Interceptor","text":"Interceptor\n\nAbstract type for gRPC interceptors.\n\nInterceptors are callables that wrap handler execution, allowing for cross-cutting concerns like logging, authentication, metrics, and error handling.\n\nRequired Interface\n\nSubtypes must be callable with signature:\n\n(interceptor)(ctx::ServerContext, request_or_stream, info::MethodInfo, next::Function) -> response\n\nArguments\n\nctx::ServerContext: Request context\nrequest_or_stream: Request message (unary/server streaming) or stream (client/bidi streaming)\ninfo::MethodInfo: Method information\nnext::Function: Next handler in the chain (call to continue processing)\n\nExample\n\nstruct AuthInterceptor <: Interceptor\n    required_scope::String\nend\n\nfunction (i::AuthInterceptor)(ctx, request, info, next)\n    token = get_metadata_string(ctx, \"authorization\")\n    if token === nothing\n        throw(GRPCError(StatusCode.UNAUTHENTICATED, \"Missing authorization\"))\n    end\n\n    # Validate token and check scope\n    if !validate_token(token, i.required_scope)\n        throw(GRPCError(StatusCode.PERMISSION_DENIED, \"Insufficient scope\"))\n    end\n\n    return next(ctx, request)\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.MethodInfo","page":"API Reference","title":"gRPCServer.MethodInfo","text":"MethodInfo\n\nInformation about the method being called, provided to interceptors.\n\nFields\n\nservice_name::String: Fully-qualified service name (e.g., \"helloworld.Greeter\")\nmethod_name::String: Method name (e.g., \"SayHello\")\nmethod_type::MethodType.T: RPC pattern type\n\nExample\n\nstruct LoggingInterceptor <: Interceptor end\n\nfunction (::LoggingInterceptor)(ctx, request, info::MethodInfo, next)\n    @info \"Calling\" service=info.service_name method=info.method_name\n    return next(ctx, request)\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.LoggingInterceptor","page":"API Reference","title":"gRPCServer.LoggingInterceptor","text":"LoggingInterceptor <: Interceptor\n\nBuilt-in interceptor that logs request/response information.\n\nFields\n\nlog_requests::Bool: Log incoming requests (default: true)\nlog_responses::Bool: Log responses (default: true)\nlog_errors::Bool: Log errors (default: true)\n\nExample\n\nadd_interceptor!(server, LoggingInterceptor())\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.MetricsInterceptor","page":"API Reference","title":"gRPCServer.MetricsInterceptor","text":"MetricsInterceptor <: Interceptor\n\nBuilt-in interceptor that collects request metrics.\n\nFields\n\non_request::Function: Called with (method, request_size) on each request\non_response::Function: Called with (method, status, durationms, responsesize) on each response\n\nExample\n\nmetrics = MetricsInterceptor(\n    on_request = (method, size) -> increment_counter(\"grpc_requests\", method),\n    on_response = (method, status, ms, size) -> record_histogram(\"grpc_duration\", ms, method, status)\n)\nadd_interceptor!(server, metrics)\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.TimeoutInterceptor","page":"API Reference","title":"gRPCServer.TimeoutInterceptor","text":"TimeoutInterceptor <: Interceptor\n\nBuilt-in interceptor that enforces request deadlines.\n\nFields\n\ndefault_timeout_ms::Union{Int, Nothing}: Default timeout in milliseconds if none specified\n\nExample\n\nadd_interceptor!(server, TimeoutInterceptor(default_timeout_ms=30000))  # 30 second default\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.RecoveryInterceptor","page":"API Reference","title":"gRPCServer.RecoveryInterceptor","text":"RecoveryInterceptor <: Interceptor\n\nBuilt-in interceptor that catches panics and converts them to gRPC errors.\n\nFields\n\ninclude_stack_trace::Bool: Include stack trace in error message (debug mode only)\n\nExample\n\nadd_interceptor!(server, RecoveryInterceptor(include_stack_trace=true))\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.add_interceptor!","page":"API Reference","title":"gRPCServer.add_interceptor!","text":"add_interceptor!(dispatcher::RequestDispatcher, interceptor::Interceptor)\n\nAdd a global interceptor.\n\n\n\n\n\nadd_interceptor!(dispatcher::RequestDispatcher, service_name::String, interceptor::Interceptor)\n\nAdd a service-specific interceptor.\n\n\n\n\n\nadd_interceptor!(server::GRPCServer, interceptor::Interceptor)\n\nAdd a global interceptor that applies to all services.\n\nExample\n\nadd_interceptor!(server, LoggingInterceptor())\nadd_interceptor!(server, MetricsInterceptor())\n\n\n\n\n\nadd_interceptor!(server::GRPCServer, service_name::String, interceptor::Interceptor)\n\nAdd an interceptor for a specific service.\n\nExample\n\nadd_interceptor!(server, \"helloworld.Greeter\", AuthInterceptor())\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.HealthStatus","page":"API Reference","title":"gRPCServer.HealthStatus","text":"HealthStatus\n\nService health state for the health checking service.\n\nValues\n\nUNKNOWN: Health status is unknown\nSERVING: Service is healthy and accepting requests\nNOT_SERVING: Service is not healthy\nSERVICE_UNKNOWN: Service is not registered\n\n\n\n\n\n","category":"module"},{"location":"api/#gRPCServer.set_health!","page":"API Reference","title":"gRPCServer.set_health!","text":"set_health!(server::GRPCServer, status::HealthStatus.T)\n\nSet the health status for the overall server.\n\nExample\n\nset_health!(server, HealthStatus.NOT_SERVING)  # Server entering maintenance\n\n\n\n\n\nset_health!(server::GRPCServer, service_name::String, status::HealthStatus.T)\n\nSet the health status for a specific service.\n\nExample\n\nset_health!(server, \"helloworld.Greeter\", HealthStatus.NOT_SERVING)\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.get_health","page":"API Reference","title":"gRPCServer.get_health","text":"get_health(server::GRPCServer, service_name::String=\"\") -> HealthStatus.T\n\nGet the health status for a service (or overall server if empty string).\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.HEALTH_DESCRIPTOR","page":"API Reference","title":"gRPCServer.HEALTH_DESCRIPTOR","text":"HEALTH_DESCRIPTOR::Vector{Vector{UInt8}}\n\nExtracted FileDescriptorProto messages for the gRPC Health service (grpc.health.v1). Each element is a serialized FileDescriptorProto that can be returned by the reflection service.\n\nGenerated from: specs/001-grpc-server/contracts/health.proto\n\n\n\n\n\n","category":"constant"},{"location":"api/#gRPCServer.REFLECTION_DESCRIPTOR","page":"API Reference","title":"gRPCServer.REFLECTION_DESCRIPTOR","text":"REFLECTION_DESCRIPTOR::Vector{Vector{UInt8}}\n\nExtracted FileDescriptorProto messages for the gRPC Server Reflection service (grpc.reflection.v1alpha). Each element is a serialized FileDescriptorProto that can be returned by the reflection service.\n\nGenerated from: specs/001-grpc-server/contracts/reflection.proto\n\n\n\n\n\n","category":"constant"},{"location":"api/#gRPCServer.has_health_descriptor","page":"API Reference","title":"gRPCServer.has_health_descriptor","text":"has_health_descriptor() -> Bool\n\nCheck if the Health service descriptor is available.\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.has_reflection_descriptor","page":"API Reference","title":"gRPCServer.has_reflection_descriptor","text":"has_reflection_descriptor() -> Bool\n\nCheck if the Reflection service descriptor is available.\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.start!","page":"API Reference","title":"gRPCServer.start!","text":"start!(server::GRPCServer)\n\nStart the server and begin accepting connections.\n\nThis is a non-blocking call. Use run(server) for blocking operation.\n\nThrows\n\nInvalidServerStateError: If server is not in STOPPED state\nBindError: If the server cannot bind to the address\n\nExample\n\nstart!(server)\n# Server is now running in background\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.stop!","page":"API Reference","title":"gRPCServer.stop!","text":"stop!(server::GRPCServer; force::Bool=false, timeout::Float64=0.0)\n\nStop the server.\n\nArguments\n\nserver::GRPCServer: The server to stop\nforce::Bool=false: If true, immediately close all connections\ntimeout::Float64=0.0: Override drain timeout (0 = use config)\n\nThrows\n\nInvalidServerStateError: If server is not running\n\nExample\n\nstop!(server)  # Graceful shutdown\nstop!(server; force=true)  # Immediate shutdown\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.reload_tls!","page":"API Reference","title":"gRPCServer.reload_tls!","text":"reload_tls!(server::GRPCServer)\n\nReload TLS certificates from disk.\n\nThis allows certificate rotation without server restart.\n\nThrows\n\nInvalidServerStateError: If server is not running\nArgumentError: If TLS is not configured\n\nExample\n\nreload_tls!(server)  # Reload certificates\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.set_header!","page":"API Reference","title":"gRPCServer.set_header!","text":"set_header!(ctx::ServerContext, key::String, value::String)\nset_header!(ctx::ServerContext, key::String, value::Vector{UInt8})\n\nSet a response header to be sent before the response body.\n\nHeaders must be set before the first response message is sent. Binary headers should have a \"-bin\" suffix in the key name.\n\nExample\n\nset_header!(ctx, \"x-custom-header\", \"custom-value\")\nset_header!(ctx, \"x-binary-data-bin\", UInt8[0x01, 0x02, 0x03])\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.set_trailer!","page":"API Reference","title":"gRPCServer.set_trailer!","text":"set_trailer!(ctx::ServerContext, key::String, value::String)\nset_trailer!(ctx::ServerContext, key::String, value::Vector{UInt8})\n\nSet trailing metadata to be sent after the response body.\n\nTrailers are sent at the end of the response stream and can be used to communicate status information determined during processing.\n\nExample\n\nset_trailer!(ctx, \"x-processing-time\", \"150ms\")\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.get_metadata","page":"API Reference","title":"gRPCServer.get_metadata","text":"get_metadata(stream::HTTP2Stream) -> Vector{Tuple{String, String}}\n\nGet all custom metadata headers (non-pseudo, non-reserved).\n\n\n\n\n\nget_metadata(ctx::ServerContext, key::String) -> Union{String, Vector{UInt8}, Nothing}\n\nGet request metadata by key (case-insensitive).\n\nExample\n\nauth = get_metadata(ctx, \"authorization\")\nif auth === nothing\n    throw(GRPCError(StatusCode.UNAUTHENTICATED, \"Missing authorization\"))\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.get_metadata_string","page":"API Reference","title":"gRPCServer.get_metadata_string","text":"get_metadata_string(ctx::ServerContext, key::String) -> Union{String, Nothing}\n\nGet request metadata as a string (returns nothing for binary metadata).\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.get_metadata_binary","page":"API Reference","title":"gRPCServer.get_metadata_binary","text":"get_metadata_binary(ctx::ServerContext, key::String) -> Union{Vector{UInt8}, Nothing}\n\nGet request metadata as binary (converts strings to bytes if needed).\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.remaining_time","page":"API Reference","title":"gRPCServer.remaining_time","text":"remaining_time(ctx::ServerContext) -> Union{Float64, Nothing}\n\nGet the remaining time until the deadline in seconds.\n\nReturns nothing if no deadline is set. Returns negative value if deadline has passed.\n\nExample\n\nremaining = remaining_time(ctx)\nif remaining !== nothing && remaining < 0\n    throw(GRPCError(StatusCode.DEADLINE_EXCEEDED, \"Deadline exceeded\"))\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.is_cancelled","page":"API Reference","title":"gRPCServer.is_cancelled","text":"is_cancelled(ctx::ServerContext) -> Bool\n\nCheck if the request has been cancelled by the client.\n\nExample\n\nif is_cancelled(ctx)\n    throw(GRPCError(StatusCode.CANCELLED, \"Request cancelled by client\"))\nend\n\n\n\n\n\nis_cancelled(stream::ClientStream) -> Bool\n\nCheck if the stream has been cancelled.\n\n\n\n\n\nis_cancelled(stream::BidiStream) -> Bool\n\nCheck if the stream has been cancelled.\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.CompressionCodec","page":"API Reference","title":"gRPCServer.CompressionCodec","text":"CompressionCodec\n\nSupported compression algorithms for gRPC messages.\n\nValues\n\nIDENTITY: No compression\nGZIP: Gzip compression\nDEFLATE: Deflate compression\n\n\n\n\n\n","category":"module"},{"location":"api/#gRPCServer.compress","page":"API Reference","title":"gRPCServer.compress","text":"compress(data::Vector{UInt8}, codec::CompressionCodec.T) -> Vector{UInt8}\n\nCompress data using the specified codec.\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.decompress","page":"API Reference","title":"gRPCServer.decompress","text":"decompress(data::Vector{UInt8}, codec::CompressionCodec.T) -> Vector{UInt8}\n\nDecompress data using the specified codec.\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.codec_name","page":"API Reference","title":"gRPCServer.codec_name","text":"codec_name(codec::CompressionCodec.T) -> String\n\nGet the gRPC encoding name for a compression codec.\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.parse_codec","page":"API Reference","title":"gRPCServer.parse_codec","text":"parse_codec(name::String) -> Union{CompressionCodec.T, Nothing}\n\nParse a gRPC encoding name to a compression codec. Returns nothing if the encoding is not supported.\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.negotiate_compression","page":"API Reference","title":"gRPCServer.negotiate_compression","text":"negotiate_compression(\n    client_encodings::Vector{CompressionCodec.T},\n    server_codecs::Vector{CompressionCodec.T}\n) -> CompressionCodec.T\n\nNegotiate compression codec between client and server. Returns the first codec supported by both, preferring client order. Falls back to IDENTITY if no common codec.\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.can_send","page":"API Reference","title":"gRPCServer.can_send","text":"can_send(stream::HTTP2Stream) -> Bool\n\nCheck if data can be sent on this stream.\n\n\n\n\n\ncan_send(controller::FlowController, stream_id::UInt32, size::Int) -> Bool\n\nCheck if data of the given size can be sent on the stream.\n\n\n\n\n\n","category":"function"},{"location":"api/#gRPCServer.StreamError","page":"API Reference","title":"gRPCServer.StreamError","text":"StreamError <: Exception\n\nError related to HTTP/2 stream processing.\n\nFields\n\nstream_id::UInt32: Stream that caused the error\nerror_code::UInt32: HTTP/2 error code\nmessage::String: Error description\n\n\n\n\n\n","category":"type"},{"location":"api/#gRPCServer.FrameType","page":"API Reference","title":"gRPCServer.FrameType","text":"FrameType\n\nHTTP/2 frame types per RFC 7540 Section 6.\n\nFrame Types\n\nDATA (0x0): Conveys payload data\nHEADERS (0x1): Opens a stream and carries header block\nPRIORITY (0x2): Specifies stream priority\nRST_STREAM (0x3): Terminates a stream\nSETTINGS (0x4): Configuration parameters\nPUSH_PROMISE (0x5): Server push notification\nPING (0x6): Connectivity check and RTT measurement\nGOAWAY (0x7): Connection shutdown notification\nWINDOW_UPDATE (0x8): Flow control window adjustment\nCONTINUATION (0x9): Header block continuation\n\n\n\n\n\n","category":"module"},{"location":"api/#gRPCServer.FrameFlags","page":"API Reference","title":"gRPCServer.FrameFlags","text":"FrameFlags\n\nHTTP/2 frame flags per RFC 7540.\n\nCommon Flags\n\nEND_STREAM (0x1): Last frame for stream (DATA, HEADERS)\nEND_HEADERS (0x4): End of header block (HEADERS, PUSH_PROMISE, CONTINUATION)\nPADDED (0x8): Frame is padded (DATA, HEADERS, PUSH_PROMISE)\nPRIORITY (0x20): Stream dependency info present (HEADERS)\nACK (0x1): Settings/Ping acknowledgment (SETTINGS, PING)\n\n\n\n\n\n","category":"module"},{"location":"api/#gRPCServer.ErrorCode","page":"API Reference","title":"gRPCServer.ErrorCode","text":"ErrorCode\n\nHTTP/2 error codes per RFC 7540 Section 7.\n\nError Codes\n\nNO_ERROR (0x0): No error\nPROTOCOL_ERROR (0x1): Protocol error detected\nINTERNAL_ERROR (0x2): Internal error\nFLOW_CONTROL_ERROR (0x3): Flow control violation\nSETTINGS_TIMEOUT (0x4): Settings not acknowledged\nSTREAM_CLOSED (0x5): Frame received for closed stream\nFRAME_SIZE_ERROR (0x6): Invalid frame size\nREFUSED_STREAM (0x7): Stream refused\nCANCEL (0x8): Stream cancelled\nCOMPRESSION_ERROR (0x9): HPACK error\nCONNECT_ERROR (0xa): Connection error\nENHANCE_YOUR_CALM (0xb): Excessive load\nINADEQUATE_SECURITY (0xc): Underlying transport inadequate\nHTTP_1_1_REQUIRED (0xd): Use HTTP/1.1\n\n\n\n\n\n","category":"module"},{"location":"api/#gRPCServer.SettingsParameter","page":"API Reference","title":"gRPCServer.SettingsParameter","text":"SettingsParameter\n\nHTTP/2 SETTINGS parameters per RFC 7540 Section 6.5.2.\n\nParameters\n\nHEADER_TABLE_SIZE (0x1): HPACK dynamic table size (default: 4096)\nENABLE_PUSH (0x2): Server push enabled (default: 1)\nMAX_CONCURRENT_STREAMS (0x3): Maximum concurrent streams (default: unlimited)\nINITIAL_WINDOW_SIZE (0x4): Initial flow control window (default: 65535)\nMAX_FRAME_SIZE (0x5): Maximum frame payload size (default: 16384)\nMAX_HEADER_LIST_SIZE (0x6): Maximum header list size (default: unlimited)\n\n\n\n\n\n","category":"module"},{"location":"api/#gRPCServer.StreamState","page":"API Reference","title":"gRPCServer.StreamState","text":"StreamState\n\nHTTP/2 stream states per RFC 7540 Section 5.1.\n\nStates\n\nIDLE: Stream not yet used\nRESERVED_LOCAL: Reserved by local PUSH_PROMISE\nRESERVED_REMOTE: Reserved by remote PUSH_PROMISE\nOPEN: Active stream for both endpoints\nHALF_CLOSED_LOCAL: Local endpoint finished sending\nHALF_CLOSED_REMOTE: Remote endpoint finished sending\nCLOSED: Stream terminated\n\n\n\n\n\n","category":"module"},{"location":"api/#gRPCServer.ConnectionState","page":"API Reference","title":"gRPCServer.ConnectionState","text":"ConnectionState\n\nHTTP/2 connection state.\n\nStates\n\nPREFACE: Waiting for connection preface\nOPEN: Connection is active\nCLOSING: Sent GOAWAY, finishing pending streams\nCLOSED: Connection terminated\n\n\n\n\n\n","category":"module"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"This guide demonstrates how to create a gRPC server in Julia using gRPCServer.jl.","category":"section"},{"location":"quickstart/#Prerequisites","page":"Quick Start","title":"Prerequisites","text":"Julia 1.10 or later\nProtoBuf.jl for message type generation","category":"section"},{"location":"quickstart/#Installation","page":"Quick Start","title":"Installation","text":"using Pkg\nPkg.add(\"gRPCServer\")","category":"section"},{"location":"quickstart/#Step-1:-Define-Your-Service","page":"Quick Start","title":"Step 1: Define Your Service","text":"This example is available in examples/hello_world.\n\nCreate a .proto file defining your service:\n\n// greeter.proto\nsyntax = \"proto3\";\n\npackage helloworld;\n\nservice Greeter {\n  rpc SayHello (HelloRequest) returns (HelloReply);\n  rpc SayHelloStream (HelloRequest) returns (stream HelloReply);\n}\n\nmessage HelloRequest {\n  string name = 1;\n}\n\nmessage HelloReply {\n  string message = 1;\n}","category":"section"},{"location":"quickstart/#Step-2:-Generate-Julia-Types","page":"Quick Start","title":"Step 2: Generate Julia Types","text":"Use ProtoBuf.jl to generate Julia types directly from the .proto file (no external tools needed):\n\nusing ProtoBuf\n\n# Generate Julia structs from proto file\n# Arguments: proto_file, search_path, output_directory\nprotojl(\"greeter.proto\", \".\", \"generated\")\n\nThis creates generated/helloworld/helloworld.jl with HelloRequest and HelloReply structs.","category":"section"},{"location":"quickstart/#Step-3:-Implement-Handlers","page":"Quick Start","title":"Step 3: Implement Handlers","text":"using gRPCServer\ninclude(\"generated/helloworld/helloworld.jl\")\nusing .helloworld\n\n# Unary RPC handler\nfunction say_hello(ctx::ServerContext, request::HelloRequest)::HelloReply\n    name = isempty(request.name) ? \"World\" : request.name\n    return HelloReply(message = \"Hello, $(name)!\")\nend\n\n# Server streaming RPC handler\nfunction say_hello_stream(\n    ctx::ServerContext,\n    request::HelloRequest,\n    stream::ServerStream{HelloReply}\n)::Nothing\n    name = isempty(request.name) ? \"World\" : request.name\n    for i in 1:5\n        send!(stream, HelloReply(message = \"Hello $(i), $(name)!\"))\n        sleep(0.5)  # Simulate work\n    end\n    return nothing\nend","category":"section"},{"location":"quickstart/#Step-4:-Create-Service-Descriptor","page":"Quick Start","title":"Step 4: Create Service Descriptor","text":"struct GreeterService end\n\nfunction gRPCServer.service_descriptor(::GreeterService)\n    ServiceDescriptor(\n        \"helloworld.Greeter\",\n        Dict(\n            \"SayHello\" => MethodDescriptor(\n                \"SayHello\",\n                MethodType.UNARY,\n                \"helloworld.HelloRequest\",\n                \"helloworld.HelloReply\",\n                say_hello\n            ),\n            \"SayHelloStream\" => MethodDescriptor(\n                \"SayHelloStream\",\n                MethodType.SERVER_STREAMING,\n                \"helloworld.HelloRequest\",\n                \"helloworld.HelloReply\",\n                say_hello_stream\n            )\n        ),\n        nothing  # File descriptor for reflection (optional)\n    )\nend","category":"section"},{"location":"quickstart/#Step-5:-Create-and-Run-Server","page":"Quick Start","title":"Step 5: Create and Run Server","text":"# Create server\nhost = \"127.0.0.1\"\nport = 50051\nserver = GRPCServer(host, port)\n\n# Register service\nregister!(server, GreeterService())\n\n# Start server (blocking)\n@info \"Starting gRPC server\" host=host port=port\nrun(server)","category":"section"},{"location":"quickstart/#Complete-Example","page":"Quick Start","title":"Complete Example","text":"Save as server.jl:\n\nusing gRPCServer\n\n# Include generated types\ninclude(\"generated/helloworld/helloworld.jl\")\nusing .helloworld\n\n# Handlers\nfunction say_hello(ctx::ServerContext, request::HelloRequest)::HelloReply\n    @info \"Received request\" name=request.name request_id=ctx.request_id\n    HelloReply(message = \"Hello, $(request.name)!\")\nend\n\nfunction say_hello_stream(\n    ctx::ServerContext,\n    request::HelloRequest,\n    stream::ServerStream{HelloReply}\n)::Nothing\n    for i in 1:5\n        if ctx.cancelled\n            @warn \"Stream cancelled by client\"\n            return nothing\n        end\n        send!(stream, HelloReply(message = \"Hello $(i), $(request.name)!\"))\n        sleep(0.5)\n    end\n    return nothing\nend\n\n# Service definition\nstruct GreeterService end\n\nfunction gRPCServer.service_descriptor(::GreeterService)\n    ServiceDescriptor(\n        \"helloworld.Greeter\",\n        Dict(\n            \"SayHello\" => MethodDescriptor(\n                \"SayHello\", MethodType.UNARY,\n                \"helloworld.HelloRequest\", \"helloworld.HelloReply\",\n                say_hello\n            ),\n            \"SayHelloStream\" => MethodDescriptor(\n                \"SayHelloStream\", MethodType.SERVER_STREAMING,\n                \"helloworld.HelloRequest\", \"helloworld.HelloReply\",\n                say_hello_stream\n            )\n        ),\n        nothing\n    )\nend\n\n# Run server\nfunction main()\n    host = \"127.0.0.1\"  # 0.0.0.0 (risky)\n    port = 50051\n    server = GRPCServer(host, port;\n        enable_health_check = true,\n        enable_reflection = true\n    )\n\n    register!(server, GreeterService())\n\n    @info \"gRPC server starting\" host=host port=port\n    run(server)\nend\n\nmain()\n\nRun with:\n\njulia server.jl","category":"section"},{"location":"quickstart/#Testing-with-grpcurl","page":"Quick Start","title":"Testing with grpcurl","text":"# List services (requires reflection enabled)\ngrpcurl -plaintext localhost:50051 list\n\n# Call unary RPC\ngrpcurl -plaintext -d '{\"name\": \"Julia\"}' \\\n  localhost:50051 helloworld.Greeter/SayHello\n\n# Call streaming RPC\ngrpcurl -plaintext -d '{\"name\": \"Julia\"}' \\\n  localhost:50051 helloworld.Greeter/SayHelloStream","category":"section"},{"location":"quickstart/#Testing-with-gRPCClient.jl","page":"Quick Start","title":"Testing with gRPCClient.jl","text":"using gRPCClient\ninclude(\"generated/helloworld.jl\")\nusing .helloworld\n\n# Create channel\nchannel = gRPCClient.Channel(\"localhost\", 50051)\n\n# Create stub\nstub = GreeterStub(channel)\n\n# Call unary RPC\nresponse = stub.SayHello(HelloRequest(name = \"Julia\"))\nprintln(response.message)  # \"Hello, Julia!\"\n\n# Call streaming RPC\nfor reply in stub.SayHelloStream(HelloRequest(name = \"Julia\"))\n    println(reply.message)\nend","category":"section"},{"location":"quickstart/#Adding-Interceptors","page":"Quick Start","title":"Adding Interceptors","text":"# Add built-in logging interceptor\nadd_interceptor!(server, LoggingInterceptor())\n\n# Add metrics interceptor with callbacks\nadd_interceptor!(server, MetricsInterceptor(\n    on_request = (method, size) -> increment_counter(\"requests\"),\n    on_response = (method, status, ms, size) -> record_latency(ms)\n))","category":"section"},{"location":"quickstart/#Enabling-TLS","page":"Quick Start","title":"Enabling TLS","text":"host = \"127.0.0.1\"\nport = 50051\ntls_config = TLSConfig(\n    cert_chain = \"/path/to/server.crt\",\n    private_key = \"/path/to/server.key\",\n    client_ca = nothing,  # Set for mTLS\n    require_client_cert = false,\n    min_version = :TLSv1_2\n)\n\nserver = GRPCServer(host, port;\n    tls = tls_config\n)","category":"section"},{"location":"quickstart/#Error-Handling","page":"Quick Start","title":"Error Handling","text":"function my_handler(ctx::ServerContext, request)\n    if !is_valid(request)\n        throw(GRPCError(\n            StatusCode.INVALID_ARGUMENT,\n            \"Request validation failed\",\n            []\n        ))\n    end\n\n    user = find_user(request.user_id)\n    if user === nothing\n        throw(GRPCError(\n            StatusCode.NOT_FOUND,\n            \"User not found: $(request.user_id)\",\n            []\n        ))\n    end\n\n    return MyResponse(user = user)\nend","category":"section"},{"location":"quickstart/#Graceful-Shutdown","page":"Quick Start","title":"Graceful Shutdown","text":"# In a separate task or signal handler\nfunction shutdown(server::GRPCServer)\n    @info \"Initiating graceful shutdown...\"\n    stop!(server; timeout = 30.0)  # Wait up to 30s for in-flight requests\n    @info \"Server stopped\"\nend","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Basic-Unary-RPC","page":"Examples","title":"Basic Unary RPC","text":"A simple echo service that returns the input message:\n\nusing gRPCServer\n\nfunction echo_handler(ctx::ServerContext, request)\n    return request  # Echo back the request\nend\n\nhost = \"127.0.0.1\"\nport = 50051\nserver = GRPCServer(host, port)\n\ndescriptor = ServiceDescriptor(\n    \"example.Echo\",\n    Dict(\n        \"Echo\" => MethodDescriptor(\n            \"Echo\",\n            MethodType.UNARY,\n            \"example.Message\",\n            \"example.Message\",\n            echo_handler\n        )\n    ),\n    nothing\n)\n\ngRPCServer.register_service!(server.dispatcher, descriptor)\nrun(server)","category":"section"},{"location":"examples/#Server-Streaming","page":"Examples","title":"Server Streaming","text":"A service that streams multiple responses:\n\nfunction stream_numbers(ctx::ServerContext, request, stream::ServerStream{NumberResponse})\n    for i in 1:request.count\n        if is_cancelled(ctx)\n            return nothing\n        end\n        send!(stream, NumberResponse(value = i))\n        sleep(0.1)\n    end\n    return nothing\nend\n\ndescriptor = ServiceDescriptor(\n    \"example.Numbers\",\n    Dict(\n        \"StreamNumbers\" => MethodDescriptor(\n            \"StreamNumbers\",\n            MethodType.SERVER_STREAMING,\n            \"example.CountRequest\",\n            \"example.NumberResponse\",\n            stream_numbers\n        )\n    ),\n    nothing\n)","category":"section"},{"location":"examples/#Client-Streaming","page":"Examples","title":"Client Streaming","text":"A service that receives multiple requests and returns a single response:\n\nfunction sum_numbers(ctx::ServerContext, stream::ClientStream{NumberRequest})\n    total = 0\n    for request in stream\n        total += request.value\n    end\n    return SumResponse(total = total)\nend\n\ndescriptor = ServiceDescriptor(\n    \"example.Math\",\n    Dict(\n        \"Sum\" => MethodDescriptor(\n            \"Sum\",\n            MethodType.CLIENT_STREAMING,\n            \"example.NumberRequest\",\n            \"example.SumResponse\",\n            sum_numbers\n        )\n    ),\n    nothing\n)","category":"section"},{"location":"examples/#Bidirectional-Streaming","page":"Examples","title":"Bidirectional Streaming","text":"A chat-like service with two-way streaming:\n\nfunction chat(ctx::ServerContext, stream::BidiStream{ChatMessage, ChatMessage})\n    for message in stream\n        if is_cancelled(ctx)\n            break\n        end\n        # Echo back with prefix\n        response = ChatMessage(\n            user = \"Server\",\n            text = \"You said: $(message.text)\"\n        )\n        send!(stream, response)\n    end\n    close!(stream)\n    return nothing\nend\n\ndescriptor = ServiceDescriptor(\n    \"example.Chat\",\n    Dict(\n        \"Chat\" => MethodDescriptor(\n            \"Chat\",\n            MethodType.BIDI_STREAMING,\n            \"example.ChatMessage\",\n            \"example.ChatMessage\",\n            chat\n        )\n    ),\n    nothing\n)","category":"section"},{"location":"examples/#Using-Interceptors","page":"Examples","title":"Using Interceptors","text":"","category":"section"},{"location":"examples/#Logging-Interceptor","page":"Examples","title":"Logging Interceptor","text":"host = \"127.0.0.1\"\nport = 50051\nserver = GRPCServer(host, port)\n\n# Add logging for all requests\nadd_interceptor!(server, LoggingInterceptor(\n    log_requests = true,\n    log_responses = true,\n    log_errors = true\n))","category":"section"},{"location":"examples/#Metrics-Interceptor","page":"Examples","title":"Metrics Interceptor","text":"request_counter = Ref(0)\nlatencies = Float64[]\n\nadd_interceptor!(server, MetricsInterceptor(\n    on_request = (method, size) -> begin\n        request_counter[] += 1\n    end,\n    on_response = (method, status, duration_ms, size) -> begin\n        push!(latencies, duration_ms)\n    end\n))","category":"section"},{"location":"examples/#Custom-Authentication-Interceptor","page":"Examples","title":"Custom Authentication Interceptor","text":"struct AuthInterceptor <: Interceptor\n    valid_tokens::Set{String}\nend\n\nfunction (auth::AuthInterceptor)(\n    ctx::ServerContext,\n    request::Any,\n    info::MethodInfo,\n    next::Function\n)\n    token = get_metadata_string(ctx, \"authorization\")\n\n    if token === nothing || !(token in auth.valid_tokens)\n        throw(GRPCError(\n            StatusCode.UNAUTHENTICATED,\n            \"Invalid or missing authentication token\"\n        ))\n    end\n\n    return next(ctx, request)\nend\n\nadd_interceptor!(server, AuthInterceptor(Set([\"token123\", \"token456\"])))","category":"section"},{"location":"examples/#Rate-Limiting-Interceptor","page":"Examples","title":"Rate Limiting Interceptor","text":"mutable struct RateLimitInterceptor <: Interceptor\n    requests_per_second::Int\n    window_start::Float64\n    request_count::Int\nend\n\nRateLimitInterceptor(rps::Int) = RateLimitInterceptor(rps, time(), 0)\n\nfunction (rl::RateLimitInterceptor)(\n    ctx::ServerContext,\n    request::Any,\n    info::MethodInfo,\n    next::Function\n)\n    now = time()\n\n    if now - rl.window_start >= 1.0\n        rl.window_start = now\n        rl.request_count = 0\n    end\n\n    rl.request_count += 1\n\n    if rl.request_count > rl.requests_per_second\n        throw(GRPCError(\n            StatusCode.RESOURCE_EXHAUSTED,\n            \"Rate limit exceeded\"\n        ))\n    end\n\n    return next(ctx, request)\nend\n\nadd_interceptor!(server, RateLimitInterceptor(100))","category":"section"},{"location":"examples/#Health-Checking","page":"Examples","title":"Health Checking","text":"host = \"127.0.0.1\"\nport = 50051\nserver = GRPCServer(host, port;\n    enable_health_check = true\n)\n\n# Set overall server health\nset_health!(server, HealthStatus.SERVING)\n\n# Set health for specific service\nset_health!(server, \"my.Service\", HealthStatus.SERVING)\n\n# Mark service as not ready (e.g., during maintenance)\nset_health!(server, \"my.Service\", HealthStatus.NOT_SERVING)","category":"section"},{"location":"examples/#TLS-Configuration","page":"Examples","title":"TLS Configuration","text":"","category":"section"},{"location":"examples/#Basic-TLS","page":"Examples","title":"Basic TLS","text":"tls_config = TLSConfig(\n    cert_chain = \"server.crt\",\n    private_key = \"server.key\"\n)\n\nserver = GRPCServer(host, port; tls = tls_config)","category":"section"},{"location":"examples/#Mutual-TLS-(mTLS)","page":"Examples","title":"Mutual TLS (mTLS)","text":"tls_config = TLSConfig(\n    cert_chain = \"server.crt\",\n    private_key = \"server.key\",\n    client_ca = \"ca.crt\",\n    require_client_cert = true\n)\n\nserver = GRPCServer(host, port; tls = tls_config)","category":"section"},{"location":"examples/#Hot-Reloading-Certificates","page":"Examples","title":"Hot Reloading Certificates","text":"# Reload certificates without restarting server\nreload_tls!(server)","category":"section"},{"location":"examples/#Error-Handling","page":"Examples","title":"Error Handling","text":"","category":"section"},{"location":"examples/#Returning-Specific-Status-Codes","page":"Examples","title":"Returning Specific Status Codes","text":"function my_handler(ctx::ServerContext, request)\n    if request.id < 0\n        throw(GRPCError(\n            StatusCode.INVALID_ARGUMENT,\n            \"ID must be non-negative\"\n        ))\n    end\n\n    item = find_item(request.id)\n    if item === nothing\n        throw(GRPCError(\n            StatusCode.NOT_FOUND,\n            \"Item not found: $(request.id)\"\n        ))\n    end\n\n    if !has_permission(ctx, item)\n        throw(GRPCError(\n            StatusCode.PERMISSION_DENIED,\n            \"Access denied to item $(request.id)\"\n        ))\n    end\n\n    return item\nend","category":"section"},{"location":"examples/#Error-Details","page":"Examples","title":"Error Details","text":"throw(GRPCError(\n    StatusCode.INVALID_ARGUMENT,\n    \"Multiple validation errors\",\n    Any[\n        Dict(\"field\" => \"email\", \"error\" => \"Invalid email format\"),\n        Dict(\"field\" => \"age\", \"error\" => \"Must be positive\")\n    ]\n))","category":"section"},{"location":"examples/#Context-Usage","page":"Examples","title":"Context Usage","text":"","category":"section"},{"location":"examples/#Accessing-Metadata","page":"Examples","title":"Accessing Metadata","text":"function my_handler(ctx::ServerContext, request)\n    # Get string metadata\n    auth = get_metadata_string(ctx, \"authorization\")\n\n    # Get binary metadata (keys ending in -bin)\n    trace = get_metadata_binary(ctx, \"x-trace-bin\")\n\n    # Check remaining time before deadline\n    remaining = remaining_time(ctx)\n    if remaining !== nothing && remaining < 1.0\n        @warn \"Less than 1 second remaining\"\n    end\n\n    return response\nend","category":"section"},{"location":"examples/#Setting-Response-Headers-and-Trailers","page":"Examples","title":"Setting Response Headers and Trailers","text":"function my_handler(ctx::ServerContext, request)\n    # Set response header\n    set_header!(ctx, \"x-request-id\", string(ctx.request_id))\n\n    # Set trailer (sent at end of response)\n    set_trailer!(ctx, \"x-processing-time\", \"50ms\")\n\n    return response\nend","category":"section"},{"location":"examples/#Compression","page":"Examples","title":"Compression","text":"","category":"section"},{"location":"examples/#Server-side-Compression","page":"Examples","title":"Server-side Compression","text":"host = \"127.0.0.1\"\nport = 50051\nserver = GRPCServer(host, port;\n    enabled_compression = [CompressionCodec.GZIP, CompressionCodec.DEFLATE]\n)","category":"section"},{"location":"examples/#Manual-Compression","page":"Examples","title":"Manual Compression","text":"using gRPCServer: compress, decompress, CompressionCodec\n\ndata = Vector{UInt8}(\"Large data to compress...\")\n\n# Compress with GZIP\ncompressed = compress(data, CompressionCodec.GZIP)\n\n# Decompress\noriginal = decompress(compressed, CompressionCodec.GZIP)","category":"section"},{"location":"examples/#Graceful-Shutdown","page":"Examples","title":"Graceful Shutdown","text":"host = \"127.0.0.1\"\nport = 50051\nserver = GRPCServer(host, port)\nregister!(server, MyService())\n\n# Run in background task\nserver_task = @async run(server; block = true)\n\n# Later, initiate graceful shutdown\n@info \"Shutting down...\"\nstop!(server; timeout = 30.0)\n\n# Wait for server to stop\nwait(server_task)\n@info \"Server stopped\"","category":"section"},{"location":"#gRPCServer.jl","page":"Home","title":"gRPCServer.jl","text":"A native Julia implementation of a gRPC server.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"gRPCServer.jl provides a complete gRPC server implementation in Julia, enabling you to build high-performance gRPC services. It supports all four RPC patterns, interceptors, health checking, and more.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"All RPC Patterns: Unary, server streaming, client streaming, and bidirectional streaming\nProtocol Buffer Support: Seamless integration with ProtoBuf.jl for message serialization\nInterceptors: Middleware pattern for cross-cutting concerns (logging, auth, metrics)\nHealth Checking: Standard gRPC health checking protocol (grpc.health.v1)\nCompression: GZIP and DEFLATE compression support\nTLS Support: Secure connections with TLS and mutual TLS (mTLS)\nReflection: gRPC reflection service for tooling integration","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\n\nPkg.dev(\"https://github.com/s-celles/gRPCServer.jl\")\n\n# Pkg.add(\"gRPCServer\")  # when registered","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using gRPCServer\n\n# Define a simple handler\nfunction my_handler(ctx::ServerContext, request)\n    return \"Hello, $(request.name)!\"\nend\n\n# Create server\nhost = \"127.0.0.1\"\nport = 50051\nserver = GRPCServer(host, port)\n\n# Register service\ndescriptor = ServiceDescriptor(\n    \"my.Service\",\n    Dict(\n        \"MyMethod\" => MethodDescriptor(\n            \"MyMethod\",\n            MethodType.UNARY,\n            \"my.Request\",\n            \"my.Response\",\n            my_handler\n        )\n    ),\n    nothing\n)\ngRPCServer.register_service!(server.dispatcher, descriptor)\n\n# Start server\nrun(server)\n\nSee the Quick Start guide for a complete walkthrough.","category":"section"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"Pages = [\"quickstart.md\", \"api.md\", \"examples.md\"]\nDepth = 2","category":"section"},{"location":"#License","page":"Home","title":"License","text":"MIT License","category":"section"}]
}
